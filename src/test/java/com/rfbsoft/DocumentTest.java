/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.rfbsoft;

import org.apache.http.HttpHost;
import org.elasticsearch.action.DocWriteResponse;
import org.elasticsearch.action.bulk.BulkItemResponse;
import org.elasticsearch.action.bulk.BulkProcessor;
import org.elasticsearch.action.bulk.BulkRequest;
import org.elasticsearch.action.bulk.BulkResponse;
import org.elasticsearch.action.delete.DeleteRequest;
import org.elasticsearch.action.delete.DeleteResponse;
import org.elasticsearch.action.get.*;
import org.elasticsearch.action.index.IndexRequest;
import org.elasticsearch.action.index.IndexResponse;
import org.elasticsearch.action.support.replication.ReplicationResponse;
import org.elasticsearch.action.update.UpdateRequest;
import org.elasticsearch.action.update.UpdateResponse;
import org.elasticsearch.client.RequestOptions;
import org.elasticsearch.client.RestClient;
import org.elasticsearch.client.RestHighLevelClient;
import org.elasticsearch.client.core.MultiTermVectorsRequest;
import org.elasticsearch.client.core.MultiTermVectorsResponse;
import org.elasticsearch.client.core.TermVectorsRequest;
import org.elasticsearch.client.core.TermVectorsResponse;
import org.elasticsearch.common.Strings;
import org.elasticsearch.common.unit.TimeValue;
import org.elasticsearch.common.xcontent.XContentBuilder;
import org.elasticsearch.common.xcontent.XContentFactory;
import org.elasticsearch.common.xcontent.XContentType;
import org.elasticsearch.index.VersionType;
import org.elasticsearch.index.query.TermQueryBuilder;
import org.elasticsearch.index.reindex.*;
import org.elasticsearch.script.Script;
import org.elasticsearch.script.ScriptType;
import org.elasticsearch.search.fetch.subphase.FetchSourceContext;
import org.junit.After;
import org.junit.Before;
import org.junit.FixMethodOrder;
import org.junit.Test;
import org.junit.runners.MethodSorters;

import java.io.IOException;
import java.util.*;
import java.util.concurrent.TimeUnit;

import static org.junit.Assert.*;


@FixMethodOrder(MethodSorters.NAME_ASCENDING)
public class DocumentTest {
    RestHighLevelClient client;
    private String index = "posts-1";
    private String id = "1";
    boolean disableDelete = true;

    @Before
    public void construct() {
        client = new RestHighLevelClient(
                RestClient.builder(
                        new HttpHost("localhost", 9200, "http")));
    }

    @After
    public void destruct() throws IOException {
        client.close();

    }

    private GetResponse getResult() throws IOException {
        GetRequest getRequest = new GetRequest(
                index,
                id);

        GetResponse getResponse = client.get(getRequest, RequestOptions.DEFAULT);
        return getResponse;
    }


    //    MethodName_StateUnderTest_ExpectedBehavior
    @Test
    public void o0_createIndex_creatingAnIndexWithFakeData_succesfullyCreatedIndex() throws IOException {
        Map<String, Object> jsonMap = new HashMap<>();
        jsonMap.put("user", "kimchy");
        jsonMap.put("postDate", new Date());
        jsonMap.put("message", "trying out Elasticsearch");
        jsonMap.put("count", 10);
        IndexRequest indexRequest = new IndexRequest(index)
                .id(id).source(jsonMap);

        IndexResponse indexResponse = client.index(indexRequest, RequestOptions.DEFAULT);

        DocWriteResponse.Result result = indexResponse.getResult();
        String index = indexResponse.getIndex();
        String id = indexResponse.getId();
        System.out.println(id);
        System.out.println(result);
        System.out.println(index);

        assertNotNull("reply to the registered index", result);
        assertEquals(index, index);
        assertEquals(id, id);

        ReplicationResponse.ShardInfo shardInfo = indexResponse.getShardInfo();
        if (shardInfo.getTotal() != shardInfo.getSuccessful()) {

        }
        if (shardInfo.getFailed() > 0) {
            for (ReplicationResponse.ShardInfo.Failure failure :
                    shardInfo.getFailures()) {
                String reason = failure.reason();
            }
        }

    }


    //    MethodName_StateUnderTest_ExpectedBehavior
    @Test
    public void o10_getIndex_gettingData_succesfullyGettedIndex() throws IOException {
        GetResponse getResponse = getResult();
        Map<String, Object> fields = getResponse.getSourceAsMap();

        String index = getResponse.getIndex();
        String id = getResponse.getId();
        System.out.println(id);
        System.out.printf("fields ==> %s", fields);
        System.out.println(index);

        assertNotNull("reply to the registered index", fields);
        assertEquals("kimchy", fields.get("user"));

    }


    //    MethodName_StateUnderTest_ExpectedBehavior
    @Test
    public void o20_updateIndex_updateExistingRecordsWithUsingMap_succesfullyUpdatedIndex() throws IOException {
        Map<String, Object> jsonMap = new HashMap<>();
        jsonMap.put("updated", new Date());
        jsonMap.put("reason", "daily update");
        jsonMap.put("count", 0);
        var request = new UpdateRequest(index, id)
                .doc(jsonMap);

        request.fetchSource(true);

        var updateResponse = client.update(
                request, RequestOptions.DEFAULT);


        var result = updateResponse.getResult();
        var index = updateResponse.getIndex();
        var id = updateResponse.getId();
        System.out.println(id);
        System.out.println(result);
        System.out.println(index);

        var getResult = updateResponse.getGetResult();
        System.out.println(getResult.sourceAsString());
        var documentFields = getResult.sourceAsMap();
        System.out.println(documentFields.size());
        documentFields.forEach((key, value) -> {
            System.out.println(key + ":" + value);
        });
        var reason = documentFields.get("reason");
        var count = documentFields.get("count");


        assertNotNull("reply to the updated index", result);
        assertEquals(index, index);
        assertEquals(id, id);
        assertEquals("daily update", reason);
        assertEquals(0, count);


    }

    //    MethodName_StateUnderTest_ExpectedBehavior
    @Test
    public void o30_updateIndex_updateExistingRecordsWithUsingJsonString_succesfullyUpdatedIndex() throws IOException {


        UpdateRequest request = new UpdateRequest(index, id);
        String jsonString = "{\"reason\":\"upsert\"}";
        request.doc(jsonString, XContentType.JSON);

        request.fetchSource(true);

        var updateResponse = client.update(
                request, RequestOptions.DEFAULT);


        var result = updateResponse.getResult();
        var index = updateResponse.getIndex();
        var id = updateResponse.getId();
        System.out.println(id);
        System.out.println(result);
        System.out.println(index);

        var getResult = updateResponse.getGetResult();
        System.out.println(getResult.sourceAsString());
        var documentFields = getResult.sourceAsMap();
        System.out.println(documentFields.size());
        documentFields.forEach((key, value) -> {
            System.out.println(key + ":" + value);
        });
        var reason = documentFields.get("reason");


        assertNotNull("reply to the updated index", result);
        assertEquals(index, index);
        assertEquals(id, id);
        assertEquals("upsert", reason);


    }

    //    MethodName_StateUnderTest_ExpectedBehavior
    @Test
    public void o40_updateIndex_updateExistingRecordsWithUsingXContentBuilder_succesfullyUpdatedIndex() throws IOException {


        UpdateRequest request = new UpdateRequest(index, id);
        XContentBuilder builder = XContentFactory.jsonBuilder();
        builder.startObject();
        {
            builder.timeField("updated", new Date());
            builder.field("reason", "XContentBuilder");
//            builder.field("painless" , 1);
        }
        builder.endObject();

        request.doc(builder);


        request.fetchSource(true);

        var updateResponse = client.update(
                request, RequestOptions.DEFAULT);


        var result = updateResponse.getResult();
        var index = updateResponse.getIndex();
        var id = updateResponse.getId();
        System.out.println(id);
        System.out.println(result);
        System.out.println(index);

        var getResult = updateResponse.getGetResult();
        System.out.println(getResult.sourceAsString());
        var documentFields = getResult.sourceAsMap();
        System.out.println(documentFields.size());
        documentFields.forEach((key, value) -> {
            System.out.println(key + ":" + value);
        });
        var reason = documentFields.get("reason");


        assertNotNull("reply to the updated index", result);
        assertEquals(index, index);
        assertEquals(id, id);
        assertEquals("XContentBuilder", reason);


    }

    //    MethodName_StateUnderTest_ExpectedBehavior
    @Test
    public void o50_updateIndex_updateExistingRecordsWithUsingScript_succesfullyUpdatedIndex() throws IOException {

        var getOldResult = getResult();
        var count = (Integer) getOldResult.getSource().get("count");
        System.out.printf("Getted Count id %d", count);
        final var addCount = 4;

        var request = new UpdateRequest(index, id);
        Map<String, Object> parameters = new HashMap<>();
        parameters.put("count", addCount);
        Script inline = new Script(ScriptType.INLINE, "painless",
                "ctx._source.count += params.count", parameters);
        request.script(inline);


        request.fetchSource(true);

        var updateResponse = client.update(
                request, RequestOptions.DEFAULT);


        var result = updateResponse.getResult();
        var index = updateResponse.getIndex();
        var id = updateResponse.getId();
        System.out.println(id);
        System.out.println(result);
        System.out.println(index);

        var getResult = updateResponse.getGetResult();
        System.out.println(getResult.sourceAsString());
        var documentFields = getResult.sourceAsMap();
        System.out.println(documentFields.size());
        System.out.printf("fields => %s", documentFields);

        var updatedCount = documentFields.get("count");


        assertNotNull("reply to the updated index", result);
        assertEquals(index, index);
        assertEquals(id, id);
        assertEquals(count + addCount, updatedCount);


    }

    //    MethodName_StateUnderTest_ExpectedBehavior
    @Test
    public void o60_deleteIndex_deleteExistingRecord_succesfullyDeletedIndex() throws IOException {
        if(disableDelete) return;

        DeleteRequest request = new DeleteRequest(
                index,
                id);


        DeleteResponse deleteResponse = client.delete(
                request, RequestOptions.DEFAULT);


        String index = deleteResponse.getIndex();
        String id = deleteResponse.getId();
        long version = deleteResponse.getVersion();
        System.out.println(index);
        System.out.println(id);
        System.out.println(version);
        DocWriteResponse.Result result = deleteResponse.getResult();
        System.out.printf("%s \n", result.toString());
        assertEquals(DocWriteResponse.Result.DELETED, result);


    }


    //    MethodName_StateUnderTest_ExpectedBehavior

    @Test
    public void o70_termVectorsRequest_createTermVectorsRequest_succesfullycreatedTermVectorsRequest() throws IOException {


        XContentBuilder docBuilder = XContentFactory.jsonBuilder();
        docBuilder.startObject().field("user", "kimchy").endObject();
        TermVectorsRequest request = new TermVectorsRequest(index,
                docBuilder);


        TermVectorsResponse response =
                client.termvectors(request, RequestOptions.DEFAULT);


        for (TermVectorsResponse.TermVector tv : response.getTermVectorsList()) {
            String fieldname = tv.getFieldName();
            System.out.printf("fieldname => %s \n" , fieldname);
            int docCount = tv.getFieldStatistics().getDocCount();
            System.out.printf("docCount => %d \n" , docCount);
            long sumTotalTermFreq =
                    tv.getFieldStatistics().getSumTotalTermFreq();


            System.out.printf("sumTotalTermFreq => %d \n" , sumTotalTermFreq);
            long sumDocFreq = tv.getFieldStatistics().getSumDocFreq();

            System.out.printf("sumDocFreq => %d \n" , sumDocFreq);
            if (tv.getTerms() != null) {
                List<TermVectorsResponse.TermVector.Term> terms =
                        tv.getTerms();
                for (TermVectorsResponse.TermVector.Term term : terms) {
                    String termStr = term.getTerm();
                    int termFreq = term.getTermFreq();

                }
            }
        }


        String localIndex = response.getIndex();
        String type = response.getType();
        String id = response.getId();
        boolean found = response.getFound();

        System.out.printf("index => %s\n" , localIndex);
        System.out.printf("type => %s\n" , type);
        System.out.printf("id => %s\n" , id);
        System.out.printf("found=> %s\n" , found);
        assertEquals(localIndex ,index );
        assertEquals(type ,"_doc" );






    }

    @Test
    public void o80_bulkApiRequest_testBulkApiIndexRequests_succesfullyTestedBulkApi() throws IOException {
        // TODO complete this test

        BulkRequest request = new BulkRequest();
        request.add(new IndexRequest(index).id("1")
                .source(XContentType.JSON,"field", "title"));
        request.add(new IndexRequest(index).id("2")
                .source(XContentType.JSON,"field", "bar"));
        request.add(new IndexRequest(index).id("3")
                .source(XContentType.JSON,"field", "baz"));


        BulkResponse bulkResponse = client.bulk(request, RequestOptions.DEFAULT);

        if (bulkResponse.hasFailures()) {

        }

        for (BulkItemResponse bulkItemResponse : bulkResponse) {
            if (bulkItemResponse.isFailed()) {
                BulkItemResponse.Failure failure =
                        bulkItemResponse.getFailure();
            }
        }



        for (BulkItemResponse bulkItemResponse : bulkResponse) {
            DocWriteResponse itemResponse = bulkItemResponse.getResponse();

            switch (bulkItemResponse.getOpType()) {
                case INDEX:
                case CREATE:
                    IndexResponse indexResponse = (IndexResponse) itemResponse;

                    break;
                case UPDATE:
                    UpdateResponse updateResponse = (UpdateResponse) itemResponse;
                    break;
                case DELETE:
                    DeleteResponse deleteResponse = (DeleteResponse) itemResponse;
            }
        }

    }


    @Test
    public void o90_bulkApiRequest_testBulkApiCrudRequests_succesfullyTestedBulkApi() throws IOException {
        // TODO complete this test

        BulkRequest request = new BulkRequest();
        request.add(new DeleteRequest(index, "3"));
        request.add(new UpdateRequest(index, "2")
                .doc(XContentType.JSON,"other", "test"));
        request.add(new IndexRequest(index).id("4")
                .source(XContentType.JSON,"field", "baz"));

        BulkResponse bulkResponse = client.bulk(request, RequestOptions.DEFAULT);

        if (bulkResponse.hasFailures()) {

        }

        for (BulkItemResponse bulkItemResponse : bulkResponse) {
            if (bulkItemResponse.isFailed()) {
                BulkItemResponse.Failure failure =
                        bulkItemResponse.getFailure();
            }
        }



        for (BulkItemResponse bulkItemResponse : bulkResponse) {
            DocWriteResponse itemResponse = bulkItemResponse.getResponse();

            switch (bulkItemResponse.getOpType()) {
                case INDEX:
                case CREATE:
                    IndexResponse indexResponse = (IndexResponse) itemResponse;

                    break;
                case UPDATE:
                    UpdateResponse updateResponse = (UpdateResponse) itemResponse;
                    break;
                case DELETE:
                    DeleteResponse deleteResponse = (DeleteResponse) itemResponse;
            }
        }

    }

    @Test
    public void p10_bulkApiRequest_testBulkProcessorCrudRequests_succesfullyTestedBulkApi() throws IOException, InterruptedException {
        // TODO complete this test



        BulkProcessor.Listener listener = new BulkProcessor.Listener() {
            @Override
            public void beforeBulk(long executionId, BulkRequest request) {
                int numberOfActions = request.numberOfActions();
                System.out.printf("Executing bulk [%s] with %s requests\n",
                        executionId, numberOfActions);

            }

            @Override
            public void afterBulk(long executionId, BulkRequest request,
                                  BulkResponse response) {
                if (response.hasFailures()) {
                    System.out.printf("Bulk [%s] executed with failures\n", executionId);
                } else {
                    System.out.printf("Bulk [%s] completed in %s milliseconds\n",
                            executionId, response.getTook().getMillis());
                }
            }

            @Override
            public void afterBulk(long executionId, BulkRequest request,
                                  Throwable failure) {
                System.out.printf("Failed to execute bulk\n", failure);
            }
        };



        BulkProcessor bulkProcessor = BulkProcessor.builder(
                (bulkRequest, bulkListener) ->
                {
                    client.bulkAsync(bulkRequest, RequestOptions.DEFAULT, bulkListener);
                },
                listener).build();


        IndexRequest one = new IndexRequest(index).id("1")
                .source(XContentType.JSON, "title",
                        "In which order are my Elasticsearch queries executed?");
        IndexRequest two = new IndexRequest(index).id("2")
                .source(XContentType.JSON, "title",
                        "Current status and upcoming changes in Elasticsearch");
        IndexRequest three = new IndexRequest(index).id("3")
                .source(XContentType.JSON, "title",
                        "The Future of Federated Search in Elasticsearch");

        bulkProcessor.add(one);
        bulkProcessor.add(two);
        bulkProcessor.add(three);




        boolean terminated = bulkProcessor.awaitClose(30, TimeUnit.MINUTES);
        System.out.printf("terminated => %s \n" , terminated);
    }

    @Test
    public void p20_multiApiRequest_testMutliGetRequests_succesfullyTestedMultiGetApi() throws IOException, InterruptedException {
        // TODO complete this test




        MultiGetRequest request = new MultiGetRequest();
        request.add(new MultiGetRequest.Item(
                index,
                id));
        request.add(new MultiGetRequest.Item(index, id));



        request.add(new MultiGetRequest.Item(index, id)
                .fetchSourceContext(FetchSourceContext.DO_NOT_FETCH_SOURCE));



        String[] includes = new String[] {"title", "*r"};
        String[] excludes = Strings.EMPTY_ARRAY;
        FetchSourceContext fetchSourceContext =
                new FetchSourceContext(true, includes, excludes);
        request.add(new MultiGetRequest.Item(index, id)
                .fetchSourceContext(fetchSourceContext));



        includes = Strings.EMPTY_ARRAY;
        excludes = new String[] {"title", "*r"};
        fetchSourceContext =
                new FetchSourceContext(true, includes, excludes);
        request.add(new MultiGetRequest.Item(index, id)
                .fetchSourceContext(fetchSourceContext));



        request.add(new MultiGetRequest.Item(index, id)
                .storedFields("title"));
        MultiGetResponse response = client.mget(request, RequestOptions.DEFAULT);
        System.out.printf("%s\n", response.getResponses().length);
        MultiGetItemResponse item = response.getResponses()[0];
        System.out.printf("%s\n" , item.getResponse().getSourceAsString());
        Map<String, Object> sourceAsMap1 = item.getResponse().getSourceAsMap();
        Object title = sourceAsMap1.get("title");
        System.out.printf("title => %s \n" , title);
        request.add(new MultiGetRequest.Item(index, id)
                .routing("some_routing"));
        request.add(new MultiGetRequest.Item(index, id)
                .versionType(VersionType.EXTERNAL)
                .version(10123L));

        response = client.mget(request, RequestOptions.DEFAULT);

        MultiGetItemResponse firstItem = response.getResponses()[0];
        assertNull(firstItem.getFailure());
        GetResponse firstGet = firstItem.getResponse();
        String index = firstItem.getIndex();
        String id = firstItem.getId();
        if (firstGet.isExists()) {
            long version = firstGet.getVersion();
            String sourceAsString = firstGet.getSourceAsString();
            Map<String, Object> sourceAsMap = firstGet.getSourceAsMap();
            byte[] sourceAsBytes = firstGet.getSourceAsBytes();
        } else {

        }




        request = new MultiGetRequest();
        request.add(new MultiGetRequest.Item(index, id)
                .version(1000L));
        response = client.mget(request, RequestOptions.DEFAULT);
        item = response.getResponses()[0];
        assertNull(item.getResponse());
        System.out.printf("%s \n" , item.getFailure().getFailure());
        // TODO status is broken! fix in a followup
        // assertEquals(RestStatus.CONFLICT, ee.status());




    }

    @Test
    public void p30_reindexRequest_testReindexRequests_succesfullyCreatedNewIndexWithExistingIndexes() throws IOException, InterruptedException {
        // TODO complete this test



        ReindexRequest request = new ReindexRequest();
        request.setSourceIndices(index , "posts");
        request.setDestIndex("dest_1");




        request.setRefresh(true);




        request.setSourceQuery(new TermQueryBuilder("field", "baz"));



        request.setScript(
                new Script(
                        ScriptType.INLINE, "painless",
                        "if (ctx._source.user == 'kimchy') {ctx._source.likes++;}",
                        Collections.emptyMap()));


        BulkByScrollResponse bulkResponse =
                client.reindex(request, RequestOptions.DEFAULT);




        TimeValue timeTaken = bulkResponse.getTook();
        boolean timedOut = bulkResponse.isTimedOut();
        long totalDocs = bulkResponse.getTotal();
        long updatedDocs = bulkResponse.getUpdated();
        long createdDocs = bulkResponse.getCreated();
        long deletedDocs = bulkResponse.getDeleted();
        long batches = bulkResponse.getBatches();
        long noops = bulkResponse.getNoops();
        long versionConflicts = bulkResponse.getVersionConflicts();
        long bulkRetries = bulkResponse.getBulkRetries();
        long searchRetries = bulkResponse.getSearchRetries();
        TimeValue throttledMillis = bulkResponse.getStatus().getThrottled();
        TimeValue throttledUntilMillis =
                bulkResponse.getStatus().getThrottledUntil();
        List<ScrollableHitSource.SearchFailure> searchFailures =
                bulkResponse.getSearchFailures();
        List<BulkItemResponse.Failure> bulkFailures =
                bulkResponse.getBulkFailures();

        System.out.printf("timeTaken => %s \n" +
                "timedOut =>%s" +
                "totalDocs => %s" +
                "createdDocs => %s" +
                "updatedDocs => %s" , timeTaken , timedOut , totalDocs , createdDocs , updatedDocs);














    }

    @Test
    public void p40_updateByQuery_testUpdateQueryRequests_succesfullyUpdatedWithQuery() throws IOException, InterruptedException {
        // TODO complete this test




        UpdateByQueryRequest request =
                new UpdateByQueryRequest(index);





        request.setQuery(new TermQueryBuilder("user", "kimchy"));




        request.setScript(
                new Script(
                        ScriptType.INLINE, "painless",
                        "if (ctx._source.user == 'kimchy') {ctx._source.count++;}",
                        Collections.emptyMap()));


//        request.setRefresh(true);





        BulkByScrollResponse bulkResponse =
                client.updateByQuery(request, RequestOptions.DEFAULT);


        TimeValue timeTaken = bulkResponse.getTook();
        boolean timedOut = bulkResponse.isTimedOut();
        long totalDocs = bulkResponse.getTotal();
        long updatedDocs = bulkResponse.getUpdated();
        long deletedDocs = bulkResponse.getDeleted();
        long batches = bulkResponse.getBatches();
        long noops = bulkResponse.getNoops();
        long versionConflicts = bulkResponse.getVersionConflicts();
        long bulkRetries = bulkResponse.getBulkRetries();
        long searchRetries = bulkResponse.getSearchRetries();
        TimeValue throttledMillis = bulkResponse.getStatus().getThrottled();
        TimeValue throttledUntilMillis =
                bulkResponse.getStatus().getThrottledUntil();
        List<ScrollableHitSource.SearchFailure> searchFailures =
                bulkResponse.getSearchFailures();
        List<BulkItemResponse.Failure> bulkFailures =
                bulkResponse.getBulkFailures();






    }

    @Test
    public void p40_deleteByQuery_testDeleteQueryRequests_succesfullyDeletedWithQuery() throws IOException, InterruptedException {
        // TODO complete this test




        DeleteByQueryRequest request =
                new DeleteByQueryRequest (index);





        request.setQuery(new TermQueryBuilder("user", "kimchy"));






//        request.setRefresh(true);







        BulkByScrollResponse bulkResponse =
                client.deleteByQuery(request, RequestOptions.DEFAULT);






        TimeValue timeTaken = bulkResponse.getTook();
        boolean timedOut = bulkResponse.isTimedOut();
        long totalDocs = bulkResponse.getTotal();
        long deletedDocs = bulkResponse.getDeleted();
        long batches = bulkResponse.getBatches();
        long noops = bulkResponse.getNoops();
        long versionConflicts = bulkResponse.getVersionConflicts();
        long bulkRetries = bulkResponse.getBulkRetries();
        long searchRetries = bulkResponse.getSearchRetries();
        TimeValue throttledMillis = bulkResponse.getStatus().getThrottled();
        TimeValue throttledUntilMillis =
                bulkResponse.getStatus().getThrottledUntil();
        List<ScrollableHitSource.SearchFailure> searchFailures =
                bulkResponse.getSearchFailures();
        List<BulkItemResponse.Failure> bulkFailures =
                bulkResponse.getBulkFailures();








    }

    @Test
    public void p40_testMultiTermVector_test_succesfullyTested() throws IOException, InterruptedException {
        // TODO complete this test


        MultiTermVectorsRequest request = new MultiTermVectorsRequest();
        TermVectorsRequest tvrequest1 =
                new TermVectorsRequest(index, "1");
        tvrequest1.setFields("user");
        request.add(tvrequest1);

//        XContentBuilder docBuilder = XContentFactory.jsonBuilder();
//        docBuilder.startObject().field("user", "guest-user").endObject();
//        TermVectorsRequest tvrequest2 =
//                new TermVectorsRequest(index, docBuilder);
//        request.add(tvrequest2);




        MultiTermVectorsResponse response =
                client.mtermvectors(request, RequestOptions.DEFAULT);

        List<TermVectorsResponse> tvresponseList =
                response.getTermVectorsResponses();
        if (tvresponseList != null) {
            for (TermVectorsResponse tvresponse : tvresponseList) {
            }
        }








    }
}
