/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.rfbsoft;

import org.apache.http.HttpHost;
import org.apache.lucene.search.TotalHits;
import org.elasticsearch.action.get.GetRequest;
import org.elasticsearch.action.get.GetResponse;
import org.elasticsearch.action.search.*;
import org.elasticsearch.client.RequestOptions;
import org.elasticsearch.client.RestClient;
import org.elasticsearch.client.RestHighLevelClient;
import org.elasticsearch.client.core.CountRequest;
import org.elasticsearch.client.core.CountResponse;
import org.elasticsearch.common.text.Text;
import org.elasticsearch.common.unit.TimeValue;
import org.elasticsearch.index.mapper.RangeFieldMapper;
import org.elasticsearch.index.query.QueryBuilders;
import org.elasticsearch.rest.RestStatus;
import org.elasticsearch.script.ScriptType;
import org.elasticsearch.script.mustache.SearchTemplateRequest;
import org.elasticsearch.script.mustache.SearchTemplateResponse;
import org.elasticsearch.search.Scroll;
import org.elasticsearch.search.SearchHit;
import org.elasticsearch.search.SearchHits;
import org.elasticsearch.search.aggregations.Aggregation;
import org.elasticsearch.search.aggregations.Aggregations;
import org.elasticsearch.search.aggregations.bucket.terms.Terms;
import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder;
import org.elasticsearch.search.aggregations.metrics.Avg;
import org.elasticsearch.search.builder.SearchSourceBuilder;
import org.elasticsearch.search.fetch.subphase.highlight.HighlightField;
import org.elasticsearch.search.profile.ProfileResult;
import org.elasticsearch.search.profile.ProfileShardResult;
import org.elasticsearch.search.profile.aggregation.AggregationProfileShardResult;
import org.elasticsearch.search.profile.query.CollectorResult;
import org.elasticsearch.search.profile.query.QueryProfileShardResult;
import org.elasticsearch.search.sort.FieldSortBuilder;
import org.elasticsearch.search.sort.SortOrder;
import org.elasticsearch.search.suggest.Suggest;
import org.elasticsearch.search.suggest.term.TermSuggestion;
import org.junit.After;
import org.junit.Before;
import org.junit.FixMethodOrder;
import org.junit.Test;
import org.junit.runners.MethodSorters;

import java.io.IOException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;


@FixMethodOrder(MethodSorters.NAME_ASCENDING)
public class SearchTest {
    RestHighLevelClient client;
    boolean disableDelete = true;
    Map<String, String> searchParams = Collections.singletonMap("OriginCityName", "Milan");
    private final String index = "kibana_sample_data_flights";
    private final String id = "1";

    @Before
    public void construct() {
        client = new RestHighLevelClient(
                RestClient.builder(
                        new HttpHost("localhost", 9200, "http")));
    }

    @After
    public void destruct() throws IOException {
        client.close();

    }

    private GetResponse getResult() throws IOException {
        GetRequest getRequest = new GetRequest(
                index,
                id);

        GetResponse getResponse = client.get(getRequest, RequestOptions.DEFAULT);
        return getResponse;
    }


    //    MethodName_StateUnderTest_ExpectedBehavior
    @Test
    public void o0_searchApi_searchDataWithExistingIndex_succesfullySearchedIndex() throws IOException {


        SearchRequest searchRequest = new SearchRequest();
//        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
//        searchSourceBuilder.query(QueryBuilders.matchAllQuery());
//        searchRequest.source(searchSourceBuilder);


        SearchRequest searchRequest2 = new SearchRequest(index);


        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
//        sourceBuilder.query(QueryBuilders.matchAllQuery());

        searchParams.forEach((key, value) -> {
            sourceBuilder.query(QueryBuilders.termQuery(key, value));
        });

        sourceBuilder.sort(new FieldSortBuilder("OriginCountry").order(SortOrder.ASC));


        sourceBuilder.from(0);
        sourceBuilder.size(5);
        sourceBuilder.timeout(new TimeValue(60, TimeUnit.SECONDS));

        String[] includeFields = new String[]{"Origin", "OriginLocation.*", "OriginCountry", "OriginCityName"};
        String[] excludeFields = new String[]{"OriginWeather"};
        sourceBuilder.fetchSource(includeFields, excludeFields);
        searchRequest.source(sourceBuilder);


//        SuggestionBuilder termSuggestionBuilder =
//                SuggestBuilders.termSuggestion("user").text("kmichy");
//        SuggestBuilder suggestBuilder = new SuggestBuilder();
//        suggestBuilder.addSuggestion("suggest_user", termSuggestionBuilder);
//        searchSourceBuilder.suggest(suggestBuilder);
//
//
//        TermsAggregationBuilder aggregation = AggregationBuilders.terms("by_company")
//                .field("company.keyword");
//        aggregation.subAggregation(AggregationBuilders.avg("average_age")
//                .field("age"));
//        searchSourceBuilder.aggregation(aggregation);
//
//        HighlightBuilder highlightBuilder = new HighlightBuilder();
//        HighlightBuilder.Field highlightTitle =
//                new HighlightBuilder.Field("title");
//        highlightTitle.highlighterType("unified");
//        highlightBuilder.field(highlightTitle);
//        HighlightBuilder.Field highlightUser = new HighlightBuilder.Field("user");
//        highlightBuilder.field(highlightUser);
//        searchSourceBuilder.highlighter(highlightBuilder);


        SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);

        RestStatus status = searchResponse.status();
        TimeValue took = searchResponse.getTook();
        Boolean terminatedEarly = searchResponse.isTerminatedEarly();
        boolean timedOut = searchResponse.isTimedOut();

        int totalShards = searchResponse.getTotalShards();
        int successfulShards = searchResponse.getSuccessfulShards();
        int failedShards = searchResponse.getFailedShards();
        for (ShardSearchFailure failure : searchResponse.getShardFailures()) {
            // failures should be handled here
        }

        SearchHits hits = searchResponse.getHits();

        TotalHits totalHits = hits.getTotalHits();
// the total number of hits, must be interpreted in the context of totalHits.relation
        long numHits = totalHits.value;
// whether the number of hits is accurate (EQUAL_TO) or a lower bound of the total (GREATER_THAN_OR_EQUAL_TO)
        TotalHits.Relation relation = totalHits.relation;
        float maxScore = hits.getMaxScore();

        SearchHit[] searchHits = hits.getHits();
        for (SearchHit hit : searchHits) {
            String index = hit.getIndex();
            String id = hit.getId();
            float score = hit.getScore();

            String sourceAsString = hit.getSourceAsString();
            Map<String, Object> sourceAsMap = hit.getSourceAsMap();
            String documentTitle = (String) sourceAsMap.get("title");
            List<Object> users = (List<Object>) sourceAsMap.get("user");
            Map<String, Object> innerObject =
                    (Map<String, Object>) sourceAsMap.get("innerObject");
        }


        hits = searchResponse.getHits();
        for (SearchHit hit : hits.getHits()) {
            Map<String, HighlightField> highlightFields = hit.getHighlightFields();
            HighlightField highlight = highlightFields.get("title");
            Text[] fragments = highlight.fragments();
            String fragmentString = fragments[0].string();
        }

        Aggregations aggregations = searchResponse.getAggregations();
        Terms byCompanyAggregation = aggregations.get("by_company");
        Terms.Bucket elasticBucket = byCompanyAggregation.getBucketByKey("Elastic");
        Avg averageAge = elasticBucket.getAggregations().get("average_age");
        double avg = averageAge.getValue();


        RangeFieldMapper.Range range = aggregations.get("by_company");


        Map<String, Aggregation> aggregationMap = aggregations.getAsMap();
        Terms companyAggregation = (Terms) aggregationMap.get("by_company");

        for (Aggregation agg : aggregations) {
            String type = agg.getType();
            if (type.equals(TermsAggregationBuilder.NAME)) {
                elasticBucket = ((Terms) agg).getBucketByKey("Elastic");
                long numberOfDocs = elasticBucket.getDocCount();
            }
        }

        Suggest suggest = searchResponse.getSuggest();
        TermSuggestion termSuggestion = suggest.getSuggestion("suggest_user");
        for (TermSuggestion.Entry entry : termSuggestion.getEntries()) {
            for (TermSuggestion.Entry.Option option : entry) {
                String suggestText = option.getText().string();
            }
        }

        Map<String, ProfileShardResult> profilingResults =
                searchResponse.getProfileResults();
        for (Map.Entry<String, ProfileShardResult> profilingResult : profilingResults.entrySet()) {
            String key = profilingResult.getKey();
            ProfileShardResult profileShardResult = profilingResult.getValue();
            List<QueryProfileShardResult> queryProfileShardResults =
                    profileShardResult.getQueryProfileResults();
            for (QueryProfileShardResult queryProfileResult : queryProfileShardResults) {
                for (ProfileResult profileResult : queryProfileResult.getQueryResults()) {
                    String queryName = profileResult.getQueryName();
                    long queryTimeInMillis = profileResult.getTime();
                    List<ProfileResult> profiledChildren = profileResult.getProfiledChildren();
                }
                CollectorResult collectorResult = queryProfileResult.getCollectorResult();
                String collectorName = collectorResult.getName();
                Long collectorTimeInMillis = collectorResult.getTime();
                List<CollectorResult> profiledChildren = collectorResult.getProfiledChildren();

            }
            AggregationProfileShardResult aggsProfileResults =
                    profileShardResult.getAggregationProfileResults();
            for (ProfileResult profileResult : aggsProfileResults.getProfileResults()) {
                String aggName = profileResult.getQueryName();
                long aggTimeInMillis = profileResult.getTime();
                List<ProfileResult> profiledChildren = profileResult.getProfiledChildren();
            }

        }


    }

    @Test
    public void o20_searchScrollApi_searchDataWithExistingIndex_succesfullySearchedIndex() throws IOException {
        int size = 100;

        final Scroll scroll = new Scroll(TimeValue.timeValueMinutes(1L));
        SearchRequest searchRequest = new SearchRequest(index);
        searchRequest.scroll(scroll);
        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
        searchParams.forEach((key, value) -> {
            searchSourceBuilder.query(QueryBuilders.termQuery(key, value));
        });
        searchSourceBuilder.size(size);
        searchRequest.source(searchSourceBuilder);

        SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);
        String scrollId = searchResponse.getScrollId();
        SearchHit[] searchHits = searchResponse.getHits().getHits();

        while (searchHits != null && searchHits.length > 0) {

            SearchScrollRequest scrollRequest = new SearchScrollRequest(scrollId);
            scrollRequest.scroll(scroll);
            searchResponse = client.scroll(scrollRequest, RequestOptions.DEFAULT);
            scrollId = searchResponse.getScrollId();
            searchHits = searchResponse.getHits().getHits();
        }

        ClearScrollRequest clearScrollRequest = new ClearScrollRequest();
        clearScrollRequest.addScrollId(scrollId);
        ClearScrollResponse clearScrollResponse = client.clearScroll(clearScrollRequest, RequestOptions.DEFAULT);
        boolean succeeded = clearScrollResponse.isSucceeded();


    }


    @Test
    public void o30_searchScriptApi_searchDataWithExistingIndex_succesfullySearchedIndex() throws IOException {

        var size = 100;

        SearchTemplateRequest request = new SearchTemplateRequest();
        request.setRequest(new SearchRequest(index));

        request.setScriptType(ScriptType.INLINE);
        request.setScript(
                "{" +
                        "  \"query\": { \"match\" : { \"{{field}}\" : \"{{value}}\" } }," +
                        "  \"size\" : \"{{size}}\"" +
                        "}");

        Map<String, Object> scriptParams = new HashMap<>();
        searchParams.forEach((key, value) -> {
            scriptParams.put("field", key);
            scriptParams.put("value", value);
            scriptParams.put("size", size);
        });




        request.setScriptParams(scriptParams);

        SearchTemplateResponse response = client.searchTemplate(request, RequestOptions.DEFAULT);
        SearchResponse searchResponse = response.getResponse();





    }

    @Test
    public void o40_countApi_searchDataWithExistingIndex_succesfullySearchedIndex() throws IOException {



        CountRequest countRequest = new CountRequest(index);
        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
        searchParams.forEach((key, value) -> {
            searchSourceBuilder.query(QueryBuilders.termQuery(key, value));
        });



        countRequest.source(searchSourceBuilder);

        CountResponse countResponse = client
                .count(countRequest, RequestOptions.DEFAULT);

        long count = countResponse.getCount();
        RestStatus status = countResponse.status();
        Boolean terminatedEarly = countResponse.isTerminatedEarly();

        int totalShards = countResponse.getTotalShards();
        int skippedShards = countResponse.getSkippedShards();
        int successfulShards = countResponse.getSuccessfulShards();
        int failedShards = countResponse.getFailedShards();
        for (ShardSearchFailure failure : countResponse.getShardFailures()) {
            // failures should be handled here
        }





    }


}
